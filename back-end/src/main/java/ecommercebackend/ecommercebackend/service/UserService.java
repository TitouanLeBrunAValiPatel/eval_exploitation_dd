package ecommercebackend.ecommercebackend.service;

import com.fasterxml.jackson.databind.JsonNode;
import ecommercebackend.ecommercebackend.data.entity.database.Role;
import ecommercebackend.ecommercebackend.data.entity.database.User;
import ecommercebackend.ecommercebackend.data.entity.database.UserCard;
import ecommercebackend.ecommercebackend.data.entity.database.UserRole;
import ecommercebackend.ecommercebackend.data.repository.UserCardRepository;
import ecommercebackend.ecommercebackend.data.repository.UserRepository;
import ecommercebackend.ecommercebackend.data.repository.UserRolesRepository;
import ecommercebackend.ecommercebackend.dto.CardDTO;
import ecommercebackend.ecommercebackend.dto.RoleDTO;
import ecommercebackend.ecommercebackend.dto.UserDTO;
import ecommercebackend.ecommercebackend.dto.mapper.MapstructMapper;
import ecommercebackend.ecommercebackend.exception.InvalidCredentialException;
import ecommercebackend.ecommercebackend.exception.InvalidIdException;
import ecommercebackend.ecommercebackend.exception.NotfoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Service
@RequiredArgsConstructor
public class UserService implements CrudService<UserDTO> {

    private final UserRepository userRepository;
    private final RoleService roleService;
    private final UserRolesRepository userRolesRepository;
    private final UserCardRepository userCardRepository;

    @Override
    public List<UserDTO> getAllItem() {
        return MapstructMapper.INSTANCE.userToUserDTO(userRepository.findAll());
    }

    @Override
    public UserDTO getItemById(int id) throws InvalidIdException {
        User user = userRepository.findById(id);
        if (user == null) {
            throw new InvalidIdException(User.class, id);
        }
        return this.createUserDto(user);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public UserDTO addItem(UserDTO item) throws Exception {
        item.setCardDTOS(null);
        if (!item.getMail().contains("@") || !item.getMail().contains(".")) {
            throw new Exception("invalid email");
        }
//        if (item.getPassword() == null) {
//            throw new Exception("Field password is needed");
//        }
//        if (item.getName() == null) {
//            throw new Exception("Field name is needed");
//        }
        User user = MapstructMapper.INSTANCE.userDTOtoUser(item);
        if (item.getRoleDTOS() == null) {
            List<RoleDTO> roleDTOS = new ArrayList<>();
            roleDTOS.add(roleService.getItemById(2));
            item.setRoleDTOS(roleDTOS);
        }
        user = userRepository.save(user);
        for (RoleDTO roleDTO : item.getRoleDTOS()) {
            Role role = MapstructMapper.INSTANCE.rolDtoToRole(roleService.getItemById(roleDTO.getId()));
            userRolesRepository.save(new UserRole(user, role));
        }
        item.setId(user.getId());
        return item;
    }

    @Override
    public void deleteItemById(int id) {
        userRepository.deleteById(id);
    }

    @Override
    public UserDTO updateItem(UserDTO item) throws InvalidIdException {
        UserDTO user = this.getItemById(item.getId());
        item.setName(item.getName() != null ? item.getName() : user.getName());
        item.setMail(item.getMail() != null ? item.getMail() : user.getMail());
        item.setPassword(item.getPassword() != null ? item.getPassword() : user.getPassword());
        item.setSurname(item.getSurname() != null ? item.getSurname() : user.getSurname());
        item.setGender(item.getGender() != null ? item.getGender() : user.getGender());
        item.setCity(item.getCity() != null ? item.getCity() : user.getCity());
        item.setPostCode(item.getPostCode() != null ? item.getPostCode() : user.getPostCode());
        userRepository.save(MapstructMapper.INSTANCE.userDTOtoUser(item));
        return item;
    }


    public UserDTO auth(JsonNode jsonNode) throws Exception {
        String mail = jsonNode.get("mail").asText();
        User user = this.userFirstCheck(mail);
        if (user == null) {
            throw new NotfoundException(User.class);
        }
        if (!Objects.equals(user.getPassword(), jsonNode.get("password").asText())) {
            throw new InvalidCredentialException(mail);
        }
        UserDTO userDTO = this.createUserDto(user);
        userDTO.setCardDTOS(null);
        return userDTO;
    }

    @Transactional(rollbackFor = Exception.class)
    public UserDTO googleAuth(JsonNode jsonNode) throws Exception {
        String mail = jsonNode.get("mail").asText();
        User user = this.userFirstCheck(mail);
        if (user == null) {
            this.addItem(new UserDTO(
                    0,
                    jsonNode.get("name").asText(),
                    mail,
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                    null
            ));
        }
        assert user != null;
        UserDTO userDTO = this.createUserDto(user);
        userDTO.setCardDTOS(null);
        return userDTO;
    }

    public User userFirstCheck(String mail) throws Exception {
        if (!mail.contains("@") || !mail.contains(".")) {
            throw new Exception("invalid email");
        }

        return userRepository.findByMail(mail);
    }

    public UserDTO createUserDto(User user) {
        List<UserRole> userRoles = userRolesRepository.findAllByUserId(user.getId());
        List<UserCard> userCards = userCardRepository.findAllByUserId(user.getId());
        List<RoleDTO> roles = userRoles.stream()
                .map(userRole -> MapstructMapper.INSTANCE.roleToRoleDTO(userRole.getRole()))
                .toList();
        List<CardDTO> cards = userCards.stream()
                .map(userCard -> MapstructMapper.INSTANCE.cardToCardDTO(userCard.getCard()))
                .toList();
        return MapstructMapper.INSTANCE.userToUserDTO(user, roles, cards);
    }
}
