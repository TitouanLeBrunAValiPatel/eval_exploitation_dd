package ecommercebackend.ecommercebackend.service;

import com.fasterxml.jackson.databind.JsonNode;
import ecommercebackend.ecommercebackend.data.entity.database.Category;
import ecommercebackend.ecommercebackend.data.entity.database.Role;
import ecommercebackend.ecommercebackend.data.entity.database.User;
import ecommercebackend.ecommercebackend.data.entity.database.UserRole;
import ecommercebackend.ecommercebackend.data.repository.UserRepository;
import ecommercebackend.ecommercebackend.data.repository.UserRolesRepository;
import ecommercebackend.ecommercebackend.dto.CardDTO;
import ecommercebackend.ecommercebackend.dto.CartDTO;
import ecommercebackend.ecommercebackend.dto.RoleDTO;
import ecommercebackend.ecommercebackend.dto.UserDTO;
import ecommercebackend.ecommercebackend.dto.mapper.MapstructMapper;
import ecommercebackend.ecommercebackend.exception.InvalidCredentialException;
import ecommercebackend.ecommercebackend.exception.NotfoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Service
@RequiredArgsConstructor
public class UserService implements CrudService<UserDTO> {

    private final UserRepository userRepository;
    private final RoleService roleService;
    private final UserRolesRepository userRolesRepository;
    private final CardService cardService;
    private final CartService cartService;

    @Override
    public List<UserDTO> getAllItem() {
        return MapstructMapper.INSTANCE.userToUserDTO(userRepository.findAll());
    }

    @Transactional
    @Override
    public UserDTO getItemById(int id) throws Exception {
        User user = userRepository.findById(id).orElseThrow(() -> new NotfoundException(Category.class));

        return this.createUserDto(user);
    }

    @Override
    @Transactional()
    public UserDTO addItem(UserDTO item) throws Exception {
        item.setCardDTOS(null);
        if (!item.getMail().contains("@") || !item.getMail().contains(".")) {
            throw new Exception("invalid email");
        }
//        if (item.getPassword() == null) {
//            throw new Exception("Field password is needed");
//        }
//        if (item.getName() == null) {
//            throw new Exception("Field name is needed");
//        }
        User user = MapstructMapper.INSTANCE.userDTOToUser(item);
        if (item.getRoleDTOS() == null) {
            List<RoleDTO> roleDTOS = new ArrayList<>();
            roleDTOS.add(roleService.getItemById(2));
            item.setRoleDTOS(roleDTOS);
        }
        user = userRepository.save(user);
        for (RoleDTO roleDTO : item.getRoleDTOS()) {
            Role role = MapstructMapper.INSTANCE.rolDtoToRole(roleService.getItemById(roleDTO.getId()));
            userRolesRepository.save(new UserRole(user, role));
        }

        item.setId(user.getId());
//        UserDTO userDTO = MapstructMapper.INSTANCE.userToUserDTO(user);
        cartService.addItem(new CartDTO(0, item, null, 0));
        return item;
    }

    @Override
    public void deleteItemById(int id) {
        userRepository.deleteById(id);
    }

    @Transactional
    @Override
    public UserDTO updateItem(UserDTO item) throws Exception {
        UserDTO user = this.getItemById(item.getId());
        item.setName(item.getName() != null ? item.getName() : user.getName());
        item.setMail(item.getMail() != null ? item.getMail() : user.getMail());
        item.setPassword(item.getPassword() != null ? item.getPassword() : user.getPassword());
        item.setSurname(item.getSurname() != null ? item.getSurname() : user.getSurname());
        item.setGender(item.getGender() != null ? item.getGender() : user.getGender());
        item.setCity(item.getCity() != null ? item.getCity() : user.getCity());
        item.setPostCode(item.getPostCode() != null ? item.getPostCode() : user.getPostCode());
        userRepository.save(MapstructMapper.INSTANCE.userDTOToUser(item));
        return item;
    }

    @Transactional()
    public UserDTO auth(JsonNode jsonNode) throws Exception {
        String mail = jsonNode.get("mail").asText();
        User user = this.userFirstCheck(mail);
        if (user == null) {
            throw new NotfoundException(User.class);
        }
        if (!Objects.equals(user.getPassword(), jsonNode.get("password").asText())) {
            throw new InvalidCredentialException(mail);
        }
        UserDTO userDTO = this.createUserDto(user);
        userDTO.setCardDTOS(null);
        return userDTO;
    }

    @Transactional()
    public UserDTO googleAuth(JsonNode jsonNode) throws Exception {
        String name = null;
        try {
            name = jsonNode.get("name").asText();
        } catch (Exception ignored) {
        }
        String mail = jsonNode.get("mail").asText();
        User user = this.userFirstCheck(mail);
        UserDTO googleUserDTO = new UserDTO();
        if (user == null) {
            googleUserDTO.setMail(mail);
            googleUserDTO.setName(name);
            googleUserDTO = this.addItem(googleUserDTO);
        } else {
            googleUserDTO = this.createUserDto(user);
        }
        return googleUserDTO;
    }

    @Transactional()
    public User userFirstCheck(String mail) throws Exception {
        if (!mail.contains("@") || !mail.contains(".")) {
            throw new Exception("invalid email");
        }
        return userRepository.findByMail(mail);
    }

    @Transactional()
    public UserDTO createUserDto(User user) throws Exception {
        List<UserRole> userRoles = userRolesRepository.findAllByUserId(user.getId());
        List<CardDTO> cards = cardService.findAllByUserId(user.getId());
        List<RoleDTO> roles = userRoles.stream()
                .map(userRole -> MapstructMapper.INSTANCE.roleToRoleDTO(userRole.getRole()))
                .toList();
        return MapstructMapper.INSTANCE.userToUserDTO(user, roles, cards);
    }
}
