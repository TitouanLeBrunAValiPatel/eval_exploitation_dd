package ecommercebackend.ecommercebackend.data.repository;

import ecommercebackend.ecommercebackend.data.entity.database.FavoriteProduct;
import ecommercebackend.ecommercebackend.data.entity.database.Product;
import ecommercebackend.ecommercebackend.data.entity.database.User;
import ecommercebackend.ecommercebackend.dto.UserDTO;
import ecommercebackend.ecommercebackend.dto.mapper.MapstructMapper;
import ecommercebackend.ecommercebackend.dto.product.ProductDTO;
import jakarta.persistence.EntityManager;
import jakarta.persistence.criteria.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.repository.query.FluentQuery;

import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

public class UserRepositoryCustomImpl implements UserRepositoryCustom{

    @Autowired
    private EntityManager entityManager;

    @Override
    public List<UserDTO> nonexclusive(List<Long> productIds) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<User> query = cb.createQuery(User.class);
        Root<User> userRoot = query.from(User.class);
        Join<User, FavoriteProduct> favoriteProductsJoin = userRoot.join("favoriteProducts");
        Join<FavoriteProduct, Product> productJoin = favoriteProductsJoin.join("product");

        query.select(userRoot).distinct(true);
        query.where(productJoin.get("id").in(productIds));

        query.groupBy(userRoot.get("id"));
        query.having(cb.equal(cb.countDistinct(productJoin.get("id")), productIds.size()));

        List<User> users = entityManager.createQuery(query).getResultList();

        // Mapping des entités User vers des DTOs UserDTO
        return users.stream()
                .map(MapstructMapper.INSTANCE::userToUserDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<UserDTO> exclusive(List<Long> productIds) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<UserDTO> query = cb.createQuery(UserDTO.class);
        Root<User> userRoot = query.from(User.class);

        // Sous-requête pour compter le nombre de produits favoris par utilisateur
        Subquery<Long> subquery = query.subquery(Long.class);
        Root<User> subUserRoot = subquery.correlate(userRoot);
        Join<User, FavoriteProduct> favoriteProductJoin = subUserRoot.join("favoriteProducts", JoinType.LEFT);
        subquery.select(cb.countDistinct(favoriteProductJoin.get("product").get("id")))
                .where(cb.equal(subUserRoot.get("id"), userRoot.get("id")));

        // Jointure pour accéder à l'entité Product
        Join<User, FavoriteProduct> favoriteProductJoinMain = userRoot.join("favoriteProducts", JoinType.INNER);
        Join<FavoriteProduct, Product> productJoin = favoriteProductJoinMain.join("product");

        // Sélectionner uniquement les utilisateurs avec exactement les produits spécifiés
        query.select(cb.construct(UserDTO.class,
                        userRoot.get("id"),
                        userRoot.get("name"),
                        userRoot.get("mail"),
                        userRoot.get("password"),
                        userRoot.get("surname"),
                        userRoot.get("gender"),
                        userRoot.get("city"),
                        userRoot.get("address"),
                        userRoot.get("postCode")
                        ))
                .distinct(true)
                .where(cb.and(
                        cb.equal(subquery, (long) productIds.size()), // Nombre exact de produits favoris
                        productJoin.get("id").in(productIds) // Les produits spécifiés
                ));

        return entityManager.createQuery(query).getResultList();
    }
}

